pragma ton-solidity >= 0.45.0 ;

interface IRootTokenContract {

    function deployEmptyWallet(
        uint128 deploy_grams,
        uint256 wallet_public_key,
        address owner_address,
        address gas_back_address
    ) external returns(address);

    function getWalletAddress(uint256 wallet_public_key,
                              address owner_address)
      external view responsible returns(address);

}


interface ITONTokenWallet {
    function setReceiveCallback(address receive_callback,
                                bool allow_non_notifiable) external;

    function transfer(
        address to,
        uint128 tokens,
        uint128 grams,
        address send_gas_to,
        bool notify_receiver,
        TvmCell payload
    ) external;

    function destroy(
        address gas_dest
    ) external ;
}


interface ITokensReceivedCallback {
    function tokensReceivedCallback(
        address token_wallet,
        address token_root,
        uint128 amount,
        uint256 sender_public_key,
        address sender_address,
        address sender_wallet,
        address original_gas_to,
        uint128 updated_balance,
        TvmCell payload
    ) external;
}


library CONST {

  uint8 constant EXN_AUTH_FAILED         = 100 ;
  uint8 constant EXN_INVALID_ARGUMENT    = 101 ;
  uint8 constant EXN_WRONG_TOKEN         = 102 ;
  uint8 constant EXN_AUCTION_CLOSED      = 103 ;
  uint8 constant EXN_NOT_ENOUGH_VALUE    = 104 ;
  uint8 constant EXN_AUCTION_NOT_CLOSED  = 105 ;
  uint8 constant EXN_ALREADY_INITIALIZED = 106 ;
  uint8 constant EXN_INVALID_DURATION    = 107 ;
  uint8 constant EXN_NOT_ENOUGH_BALANCE  = 108 ;

}

abstract contract V_OCP_Auction is ITokensReceivedCallback {

  event Winner( address g_winner_address, uint256 g_winner_pubkey );

  uint128 constant MINIMAL_INITIAL_BALANCE = 1 ton ;
  uint128 constant DEPLOY_WALLET_GRAMS = 0.5 ton ;
  uint128 constant QUERY_ADDRESS_GRAMS = 0.1 ton ;
  uint128 constant TRANSFER_GRAMS = 0.1 ton ;

  struct Auction {
    uint256 id ;
    address initial_owner_address ;
    address owner_address ;
    uint256 owner_pubkey ;
    uint256 time_stop ;
    address root_wallet ;
    address winner_address ;
    uint256 winner_pubkey ;
    string kind ;
    string title ;
    string description ;
  }

  uint256 static s_id ;
  address static s_owner_address ;

  address g_owner_address ;
  uint256 g_owner_pubkey ;

  uint256 g_time_stop;
  address g_root_wallet ;
  address g_auction_wallet ;

  address g_winner_address ;
  uint256 g_winner_pubkey ;

  bool g_automatic_winner ;
  string g_kind ;
  string g_title ;
  string g_description ;

  function _init_auction(
                         string kind,
                         uint256 owner_pubkey,
                         address owner_address,
                         address root_wallet,
                         uint256 time_stop
           ) internal
  {

    require( address(this).balance >= MINIMAL_INITIAL_BALANCE
             , CONST.EXN_NOT_ENOUGH_BALANCE );

    require( g_owner_pubkey == 0 && g_owner_address.value == 0
             , CONST.EXN_ALREADY_INITIALIZED );

    require( ( s_owner_address.value != 0 && msg.sender == s_owner_address )
             ||
             ( msg.pubkey() != 0 && msg.pubkey() == tvm.pubkey() )
             , CONST.EXN_AUTH_FAILED );

    if( owner_address.value == 0 ){
      require( s_owner_address.value != 0, CONST.EXN_INVALID_ARGUMENT );
      owner_address = s_owner_address ;
    }

    require(
            time_stop >= now
            , CONST.EXN_INVALID_ARGUMENT );

    tvm.accept();
    g_owner_pubkey = owner_pubkey ;
    g_owner_address = owner_address ;
    g_root_wallet = IRootTokenContract(root_wallet) ;
    g_time_stop = time_stop ;
    g_kind = kind + "auction" ;

    if ( g_root_wallet.value != 0 ){

      IRootTokenContract( g_root_wallet ).deployEmptyWallet(
                                                          DEPLOY_WALLET_GRAMS,
                                                          0,
                                                          address(this),
                                                          address(this)
                                                          ) ;
      IRootTokenContract( g_root_wallet ).getWalletAddress{
          value: QUERY_ADDRESS_GRAMS,
          callback:set_wallet_address
      }(
                                                              0,
                                                              address(this)
                                                              );

    }
  }

  function set_wallet_address( address wallet_address ) public
  {
    require(
            g_root_wallet.value != 0
            && msg.sender == g_root_wallet , CONST.EXN_AUTH_FAILED );
    tvm.accept() ;
    g_auction_wallet = wallet_address ;
    ITONTokenWallet( g_auction_wallet ).
      setReceiveCallback( address(this), false );
  }

  function _tokens_received( uint128 amount,
                             address sender_wallet,
                             uint256 sender_public_key,
                             address sender_address ) internal virtual ;

  function tokensReceivedCallback(
                                  address /*token_wallet*/,
                                  address /*token_root*/,
                                  uint128 amount,
                                  uint256 sender_public_key,
                                  address sender_address,
                                  address sender_wallet,
                                  address /*original_gas_to*/,
                                  uint128 /*updated_balance*/,
                                  TvmCell /*payload*/
    ) public override
  {
    require( g_auction_wallet.value != 0
             && msg.sender == g_auction_wallet
             , CONST.EXN_AUTH_FAILED );
    tvm.accept() ;
    _tokens_received( amount, sender_wallet,
                      sender_public_key, sender_address );
  }

  function _only_after_close( ) internal view
  {
    require( g_time_stop < now, CONST.EXN_AUCTION_NOT_CLOSED );
  }

  function _only_before_close( ) internal view
  {
    require( g_time_stop > now, CONST.EXN_AUCTION_CLOSED );
  }

  function _is_owner( ) internal view returns (bool)
  {
    return
      ( g_owner_address.value != 0 &&
        msg.sender == g_owner_address )
      ||
      ( g_owner_pubkey != 0 &&
        msg.pubkey() == g_owner_pubkey ) ;
  }

  function _is_winner( ) internal view returns (bool)
  {
    return
      ( g_winner_address.value != 0 &&
        msg.sender == g_winner_address )
      ||
      ( g_winner_pubkey != 0 &&
        msg.pubkey() == g_winner_pubkey ) ;
  }

  function _only_owner( ) internal view
  {
    require( _is_owner (), CONST.EXN_AUTH_FAILED );
  }

  function _only_owner_or_winner( ) internal view
  {
    if ( g_automatic_winner &&
         ( g_winner_address.value == 0
           && g_winner_pubkey == 0 ) ){
      // no winner, winner is automatically former owner
      _only_owner() ;
    } else {
      require( _is_winner(), CONST.EXN_AUTH_FAILED );
    }
  }

  function set_description ( string title, string description ) public
  {
    _only_before_close () ;
    _only_owner () ;
    tvm.accept();
    g_title = title ;
    g_description = description ;
  }

  function set_winner_pubkey( uint256 pubkey ) public
  {
    _only_after_close () ;
    _only_owner_or_winner () ;
    tvm.accept();
    g_winner_pubkey = pubkey ;
  }

  function set_winner_address( address addr ) public
  {
    _only_after_close () ;
    _only_owner_or_winner () ;
    tvm.accept();
    g_winner_address = addr ;
  }

  function _get_auction () internal view returns ( Auction a )
  {
    a = Auction(
                s_id,
                s_owner_address,

                g_owner_address ,
                g_owner_pubkey ,

                g_time_stop ,
                g_root_wallet ,

                g_winner_address ,
                g_winner_pubkey ,

                g_kind ,
                g_title ,
                g_description
                ) ;
      }

}


abstract contract V_OCP_AuctionSetcode is V_OCP_Auction {

  function set_winner_code ( TvmCell code ) public
  {
    _only_after_close () ;
    _only_owner_or_winner () ;
    tvm.accept();
    tvm.setcode(code);
    tvm.setCurrentCode(code);
    onCodeUpgrade();
  }

  function onCodeUpgrade() private
  {
    tvm.resetStorage();
  }

}

abstract contract V_OCP_DutchAuction is V_OCP_Auction {

  uint8 constant STATUS_NOT_STARTED      = 0 ;
  uint8 constant STATUS_STARTED          = 1 ;
  uint8 constant STATUS_WON              = 2 ;
  uint8 constant STATUS_NO_WINNER        = 3 ;

  uint128 constant MINIMAL_FEE = 0.5 ton ;

  uint128 g_price_start; // The starting price
  uint128 g_price_stop; // The limit price

  function _init_dutch_auction(
                               string kind,
                               uint256 owner_pubkey,
                               address owner_address,
                               address root_wallet,
                               uint256 time_stop,
                               uint128 price_start,
                               uint128 price_stop
           ) internal
  {
    require(
            price_start > price_stop
            , CONST.EXN_INVALID_ARGUMENT );
    _init_auction (
                   kind + "dutch ",
                   owner_pubkey,
                   owner_address,
                   root_wallet,
                   time_stop
                   ) ;
    g_price_start = price_start ;
    g_price_stop = price_stop ;
    g_automatic_winner = true ;
  }

  function _current_price () internal view virtual
    returns (uint128 current_price) ;

  function _is_better_price (uint128 b) internal view returns (bool){
    uint128 current_price = _current_price() ;
    return ( g_price_start >= b && b >= current_price ) ;
  }

  receive() external
  {
    if( now > g_time_stop ){

      require( msg.sender == g_winner_address
               || msg.sender == g_owner_address
               , CONST.EXN_AUCTION_CLOSED );

    } else {

      if( msg.sender != g_owner_address ){

        require( g_root_wallet.value == 0, CONST.EXN_WRONG_TOKEN );
        require( msg.value > MINIMAL_FEE, CONST.EXN_NOT_ENOUGH_VALUE );
        uint128 proposed_price = msg.value - MINIMAL_FEE ;
        if( _is_better_price ( proposed_price  ) ){
          g_time_stop = now ;
          g_winner_address = msg.sender ;

          emit Winner( g_winner_address, g_winner_pubkey );
          g_owner_address.transfer(
                                   proposed_price +
                                   ( address(this).balance - msg.value )
                                   , false, 0 );
        } else {
          msg.sender.transfer(0, false, 64);
        }
      }
    }
  }

  function _tokens_received( uint128 amount,
                             address sender_wallet,
                             uint256 sender_public_key,
                             address sender_address ) internal override
  {
    _only_before_close () ;
    TvmCell empty ;
    if( _is_better_price( amount ) ){
      g_time_stop = now ;
      g_winner_address = sender_address ;
      g_winner_pubkey = sender_public_key ;
      emit Winner( g_winner_address, g_winner_pubkey );

      ITONTokenWallet( g_auction_wallet ).transfer (
                                                    g_owner_address,
                                                    amount,
                                                    TRANSFER_GRAMS,
                                                    address(this),
                                                    true,
                                                    empty
                                                    );
      ITONTokenWallet( g_auction_wallet ).destroy ( g_owner_address );
    } else {

      ITONTokenWallet( g_auction_wallet ).transfer (
                                                    sender_wallet,
                                                    amount,
                                                    TRANSFER_GRAMS,
                                                    address(this),
                                                    true,
                                                    empty
                                                    );

    }
  }

}

contract V_OCP_AutomaticDutchAuction is V_OCP_DutchAuction {

  uint256 constant MAXIMAL_DURATION = 365 * 24 * 3600 ; // one year

  uint128 g_price_delta; // The price decrement over time
  uint256 g_time_delta; // The time after which the time
  uint256 g_time_start; // The starting time

  function _init_automatic_dutch_auction (
                                       string kind ,
                                       uint256 owner_pubkey,
                                       address owner_address,
                                       address root_wallet,
                                       uint128 price_start,
                                       uint128 price_stop,
                                       uint256 time_start,
                                       uint128 price_delta,
                                       uint256 time_delta
                                       ) internal
  {
      require( time_delta > 0
               && time_start >= now
               && price_delta > 0
               , CONST.EXN_INVALID_ARGUMENT );
      uint256 duration = time_delta +
        ( price_start - price_stop )
        * time_delta / price_delta ;
      require ( duration <= MAXIMAL_DURATION, CONST.EXN_INVALID_DURATION );
      uint256 time_stop = time_start + duration ;
      _init_dutch_auction(
                          kind + "automatic ",
                          owner_pubkey,
                          owner_address,
                          root_wallet,
                          time_stop,
                          price_start,
                          price_stop
                          );
      g_price_delta = price_delta ;
      g_time_start = time_start ;
      g_time_delta = time_delta ;
    }

  function _current_price ()
    internal view override returns (uint128 current_price){
    uint128 price_change =
      uint128( g_price_delta * (now - g_time_start) / g_time_delta ) ;
    current_price = g_price_start - price_change ;
    if( g_price_stop > current_price ){
      current_price = g_price_stop ;
    }
  }

  function get() public view
    returns ( Auction a,
              uint128 price_start,
              uint128 price_stop,
              uint256 time_start,
              uint256 time_delta,
              uint128 current_price
              )
  {
    a = _get_auction() ;
    price_start = g_price_start ;
    price_stop = g_price_stop ;
    time_start = g_time_start ;
    time_delta = g_time_delta ;
    if( now < g_time_stop ) {
      current_price = _current_price();
    }
  }

}

contract OCP_AutomaticDutchAuction is V_OCP_AutomaticDutchAuction {

  constructor (
              uint256 owner_pubkey,
              address owner_address,
              address root_wallet,
              uint128 price_start,
              uint128 price_stop,
              uint256 time_start,
              uint128 price_delta,
              uint256 time_delta
              )  public
    {
      _init_automatic_dutch_auction(
                                 "",
                                 owner_pubkey,
                                 owner_address,
                                 root_wallet,
                                 price_start,
                                 price_stop,
                                 time_start,
                                 price_delta,
                                 time_delta
                                );
    }
}

contract OCP_AutomaticDutchAuctionSetcode is
  V_OCP_AutomaticDutchAuction, V_OCP_AuctionSetcode {
  constructor (
              uint256 owner_pubkey,
              address owner_address,
              address root_wallet,
              uint128 price_start,
              uint128 price_stop,
              uint256 time_start,
              uint128 price_delta,
              uint256 time_delta
              )  public
    {
      _init_automatic_dutch_auction(
                                 "setcode ",
                                 owner_pubkey,
                                 owner_address,
                                 root_wallet,
                                 price_start,
                                 price_stop,
                                 time_start,
                                 price_delta,
                                 time_delta
                                 );
    }
}


abstract contract V_OCP_ManualDutchAuction is V_OCP_DutchAuction {

  event NewPrice( uint128 new_price );

  uint256 g_auction_house_pubkey ;
  address g_auction_house_address ;
  uint128 g_current_price ;

  function _init_manual_dutch_auction (
                                       string kind,
                                       uint256 owner_pubkey,
                                       address owner_address,
                                       address root_wallet,
                                       uint256 time_stop,
                                       uint128 price_start,
                                       uint128 price_stop,
                                       uint256 auction_house_pubkey,
                                       address auction_house_address
               ) public
         {
           require( time_stop > now
                    , CONST.EXN_INVALID_ARGUMENT );
           _init_dutch_auction(
                               kind + "manual ",
                               owner_pubkey,
                               owner_address,
                               root_wallet,
                               time_stop,
                               price_start,
                               price_stop
                               );
           g_current_price = price_start ;
           g_auction_house_address = auction_house_address ;
           g_auction_house_pubkey = auction_house_pubkey ;
         }


  function _only_owner_or_auction_house( ) internal view returns (bool)
  {
    return
      ( g_winner_address.value != 0 &&
        msg.sender == g_winner_address )
      ||
      ( g_winner_pubkey != 0 &&
        msg.pubkey() == g_winner_pubkey ) ;
  }

  function _current_price ()
    internal view override returns (uint128 price){
    price = g_current_price ;
  }

  function update_price( uint128 new_price ) public
  {
    _only_before_close () ;

    if( g_auction_house_pubkey != 0 ||
        g_auction_house_address.value != 0 ){
      require(
              ( msg.pubkey() == 0 )
              ? ( g_auction_house_address.value != 0
                  && msg.sender == g_auction_house_address )
              : ( g_auction_house_pubkey != 0
                  && msg.pubkey() == g_auction_house_pubkey )
              , CONST.EXN_AUTH_FAILED );
    } else {
      _only_owner () ;
    }
    require(
            g_current_price >= new_price
            && new_price >= g_price_stop 
            , CONST.EXN_INVALID_ARGUMENT );
    tvm.accept();
    g_current_price = new_price ;
    emit NewPrice( new_price );
  }

  function get() public view
    returns ( Auction a,
              uint128 price_start,
              uint128 price_stop,
              uint256 auction_house_pubkey,
              address auction_house_address,
              uint128 current_price
              )
  {
    a = _get_auction() ;
    price_start = g_price_start ;
    price_stop = g_price_stop ;
    auction_house_address = g_auction_house_address ;
    auction_house_pubkey = g_auction_house_pubkey ;
    if( now < g_time_stop ) {
      current_price = _current_price();
    }
  }

}

contract OCP_ManualDutchAuction is V_OCP_ManualDutchAuction {

  constructor (
               uint256 owner_pubkey,
               address owner_address,
               address root_wallet,
               uint256 time_stop,
               uint128 price_start,
               uint128 price_stop,
               uint256 auction_house_pubkey,
               address auction_house_address
               ) public
         {
           _init_manual_dutch_auction (
                                       "",
                                       owner_pubkey,
                                       owner_address,
                                       root_wallet,
                                       time_stop,
                                       price_start,
                                       price_stop,
                                       auction_house_pubkey,
                                       auction_house_address
                                       ) ;
         }
}

contract OCP_ManualDutchAuctionSetcode is
 V_OCP_ManualDutchAuction, V_OCP_AuctionSetcode {

  constructor (
               uint256 owner_pubkey,
               address owner_address,
               address root_wallet,
               uint256 time_stop,
               uint128 price_start,
               uint128 price_stop,
               uint256 auction_house_pubkey,
               address auction_house_address
               ) public
    {
      _init_manual_dutch_auction (
                                  "setcode ",
                                  owner_pubkey,
                                  owner_address,
                                  root_wallet,
                                  time_stop,
                                  price_start,
                                  price_stop,
                                  auction_house_pubkey,
                                  auction_house_address
                                  ) ;
    }
}

abstract contract V_OCP_EnglishAuction is V_OCP_Auction {

  uint128 constant MINIMAL_FEE = 0.5 ton ;

  uint128 g_price_start ;
  uint256 g_time_delay ;

  bool g_need_refund ;
  uint256 g_time_max ;
  uint128 g_current_price ;
  uint256 g_bid_sender_pubkey ;
  address g_bid_sender_address ;
  address g_bid_sender_wallet ;

  function _init_english_auction(
                               string kind,
                               uint256 owner_pubkey,
                               address owner_address,
                               address root_wallet,
                               uint256 time_stop,
                               uint128 price_start,
                               uint256 time_delay
           ) internal
  {
    _init_auction (
                   kind + "english ",
                   owner_pubkey,
                   owner_address,
                   root_wallet,
                   time_stop
                   ) ;
    g_price_start = price_start ;
    g_time_delay = time_delay ;
    g_time_max = time_stop ;
    g_current_price = price_start ;
  }

  function commit() public
  {
    _only_after_close () ;
    require( g_need_refund || !g_automatic_winner,
             CONST.EXN_AUTH_FAILED );
    tvm.accept();

    if( g_need_refund ){
      g_need_refund = false ;
      g_owner_address = g_bid_sender_address ;
      g_owner_pubkey = g_bid_sender_pubkey ;
      if ( g_root_wallet.value == 0 ) {
        g_owner_address.transfer( g_current_price, false, 0 );
      } else {
        TvmCell empty ;
        ITONTokenWallet( g_auction_wallet ).transfer (
                                                      g_owner_address,
                                                      g_current_price,
                                                      TRANSFER_GRAMS,
                                                      address(this),
                                                      true,
                                                      empty
                                                      );
        ITONTokenWallet( g_auction_wallet ).destroy ( g_owner_address );
      }
    } else {
      g_automatic_winner = true ;
    }
  }

  receive() external
  {
    if( now > g_time_stop ){

      require( msg.sender == g_winner_address
               || msg.sender == g_owner_address
               , CONST.EXN_AUCTION_CLOSED );
      
    } else {

      if( msg.sender != g_owner_address ){

        require( g_root_wallet.value == 0, CONST.EXN_WRONG_TOKEN );
        require( msg.value > MINIMAL_FEE, CONST.EXN_NOT_ENOUGH_VALUE );
        uint128 proposed_price = msg.value - MINIMAL_FEE ;
        if( proposed_price > g_current_price  ){

          _accept_bid(
                      proposed_price ,
                      msg.sender ,
                      0 ,
                      msg.sender
                      );
        } else {
          msg.sender.transfer(0, false, 64);
        }
      }
    }
  }

  function _accept_bid(
                       uint128 proposed_price ,
                       address bid_sender_wallet ,
                       uint256 bid_sender_pubkey ,
                       address bid_sender_address
                       ) internal
  {
    if( g_need_refund ){
      if ( g_root_wallet.value == 0 ){
        g_bid_sender_address.transfer( g_current_price, false, 0 );
      } else {
        TvmCell empty ;
        ITONTokenWallet( g_auction_wallet ).transfer (
                                                      g_bid_sender_wallet,
                                                      g_current_price,
                                                      TRANSFER_GRAMS,
                                                      address(this),
                                                      true,
                                                      empty
                                                      );
      }
    }
    g_need_refund = true ;
    g_current_price = proposed_price ;
    g_bid_sender_address = bid_sender_address ;
    g_bid_sender_pubkey = bid_sender_pubkey ;
    g_bid_sender_wallet = bid_sender_wallet ;
    if( g_time_delay > 0 ){
      g_time_stop = now + g_time_delay ;
      if ( g_time_stop > g_time_max ){
        g_time_stop = g_time_max ;
      }
    }
  }

  function _tokens_received( uint128 amount,
                             address sender_wallet,
                             uint256 sender_public_key,
                             address sender_address ) internal override
  {
    _only_before_close () ;
    TvmCell empty ;
    if( amount > g_current_price ){

      _accept_bid(
                  amount ,
                  sender_wallet ,
                  sender_public_key ,
                  sender_address
                  ) ;

    } else {

      ITONTokenWallet( g_auction_wallet ).transfer (
                                                    sender_wallet,
                                                    amount,
                                                    TRANSFER_GRAMS,
                                                    address(this),
                                                    true,
                                                    empty
                                                    );

    }
  }

  function get() public view
    returns ( Auction a,
              uint128 price_start,
              uint256 time_delay
              )
  {
    a = _get_auction() ;
    price_start = g_price_start ;
    time_delay = g_time_delay ;
  }

}


contract OCP_EnglishAuction is V_OCP_EnglishAuction {

  constructor (
               uint256 owner_pubkey,
               address owner_address,
               address root_wallet,
               uint256 time_stop,
               uint128 price_start,
               uint256 time_delay
               ) public
         {
           _init_english_auction (
                                       "",
                                       owner_pubkey,
                                       owner_address,
                                       root_wallet,
                                       time_stop,
                                       price_start,
                                       time_delay
                                       ) ;
         }
}

contract OCP_EnglishAuctionSetcode is
V_OCP_EnglishAuction, V_OCP_AuctionSetcode {
  
  constructor (
               uint256 owner_pubkey,
               address owner_address,
               address root_wallet,
               uint256 time_stop,
               uint128 price_start,
               uint256 time_delay
               ) public
         {
           _init_english_auction (
                                       "setcode ",
                                       owner_pubkey,
                                       owner_address,
                                       root_wallet,
                                       time_stop,
                                       price_start,
                                       time_delay
                                       ) ;
         }
}

